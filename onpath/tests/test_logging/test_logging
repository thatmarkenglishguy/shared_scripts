#!/usr/bin/env bash

#Deduce this script's directory
if [ -z ${BASH_SOURCE} ]; then
  test_logging_script_dir=$(readlink -f $(dirname "${0}"))
else
  test_logging_script_dir="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

# Log testing
source "${test_logging_script_dir}/../../bash_script_testing"
source "${test_logging_script_dir}/../../bash_script_logging"
# Importing twice shouldn't produce any error messages
# e.g. readonly variables being redeclared.
source "${test_logging_script_dir}/../../bash_script_logging"

# Log test results
function build_log_test_description() {
  # Test for log::log()
  # Paramters:
  #  1 level
  #  2 namespace
  #  3 message
  local level
  local namespace
  local message
  local description
  local description_namespace
  local description_level
  local description_level_number

  level=${1}
  namespace="${2}"
  message="${3}"

  description_level=${level}
  if [ -z "${description_level}" ]
  then
    description_level="DEFAULT_LEVEL(${_log_current_default_level}}"
    description_level_number=${_log_current_default_level}
  else
    description_level_number=${description_level}
  fi

  case "${description_level_number}" in
    ${ERROR})
      description_level="ERROR(${description_level})"
      ;;
    ${WARN})
      description_level="WARN(${description_level})"
      ;;
    ${INFO})
      description_level="INFO(${description_level})"
      ;;
    ${DEBUG})
      description_level="DEBUG(${description_level})"
      ;;
    ${TRACE})
      description_level="TRACE(${description_level})"
      ;;
  esac

  description_namespace="${namespace}"
  if [ -z "${description_namespace}" ]
  then
    description_namespace='DEFAULT_NAMESPACE'
  else
    description_namespace="'${description_namespace}'"
  fi

  description="log::log level=${description_level} namespace=${description_namespace} message='${message}'"
  echo "${description}"
}

function show_log_test_result() {
  local level
  local namespace
  local message
  local expected
  local output
  local description

  level=${1}
  namespace="${2}"
  message="${3}"
  expected="${4}"
  output="${5}"

  description="$(build_log_test_description "${level}" "${namespace}" "${message}")"

  test::assert_compare "${message}" "${expected}" "${output}" "${description}"
}

# Log functionality testing

function test_effective_level() {
  local namespace
  local expected_level
  local effective_level
  namespace="${1}"
  expected_level=${2}

  effective_level=$(log::_effective_log_level "${namespace}")

  test::assert_equal "${effective_level}" "${expected_level}" "Effective level"
}

function test_log() {
  # Test for log::log()
  # Paramters:
  #  1 level
  #  2 namespace
  #  3 message
  #  4 expected output. Note: EMPTY expects empty, SAME expects message,
  #                           anything else is used verbatim.
  local output

  output="$(log::log "${1}" "${2}" "${3}" 3>&2 2>&1 1>&3)"

  show_log_test_result "${1}" "${2}" "${3}" "${4}" "${output}"
}

# Testing specific level functions. All have the same parameters:
# Paramters:
#  1 namespace
#  2 message
#  3 expected output. Note: EMPTY expects empty, SAME expects message,
#                           anything else is used verbatim.
function test_error() {
  local output
  output="$(log::error "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${ERROR} "${1}" "${2}" "${3}" "${output}"
}

function test_warn() {
  local output
  output="$(log::warn "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${WARN} "${1}" "${2}" "${3}" "${output}"
}

function test_info() {
  local output
  output="$(log::info "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${INFO} "${1}" "${2}" "${3}" "${output}"
}

function test_debug() {
  local output
  output="$(log::debug "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${DEBUG} "${1}" "${2}" "${3}" "${output}"
}

function test_trace() {
  local output
  output="$(log::trace "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${TRACE} "${1}" "${2}" "${3}" "${output}"
}

## Command line
test::process_command_line_args "${0}" "${@}"

## The Tests
test::section 'effective_levels' 'Effective levels'
log::reset
#log::_dump_namespaces
test_effective_level 'foo' ${INFO}
test_effective_level 'foo.bar' ${INFO}
test_effective_level 'foo.bar.la' ${INFO}

test::announce 'set foo.bar to DEBUG'
log::set_level 'foo.bar' ${DEBUG}
#log::_dump_namespaces
test_effective_level 'foo' ${INFO}
test_effective_level 'foo.bar' ${DEBUG}
test_effective_level 'foo.bar.la' ${DEBUG}
test::newline

test::section 'changing_default_level' 'Logging and changing default level'
log::reset
# Default level is INFO
test_log '' '' 'log::log() default' SAME
test_log ${DEBUG} '' 'log::log() debug explicit' EMPTY
test_debug '' 'log::debug()' EMPTY
log::set_default_level ${DEBUG}
test_log ${DEBUG} '' 'log::log() debug with default level at DEBUG' SAME
test_log '' '' 'log::log() debug with default level at DEBUG' SAME
test_debug '' 'log::debug() with default level at DEBUG' SAME
test::newline

test::section 'namespace_levels' 'Namespace levels'
log::reset
test_info 'foo' 'log::info() foo namespace' SAME
test_debug 'foo' 'log::debug() foo namespace' EMPTY
test_info 'foo.bar' 'log::info() foo.bar namespace' SAME
test_debug 'foo.bar' 'log::debug() foo.bar namespace' EMPTY
test_info 'foo.bar.la' 'log::info() foo.bar.la namespace' SAME
test_debug 'foo.bar.la' 'log::debug() foo.bar.la namespace' EMPTY

test::announce 'set foo.bar to DEBUG'
log::set_level 'foo.bar' ${DEBUG}
test_info 'foo' 'log::info() foo namespace' SAME
test_debug 'foo' 'log::debug() foo namespace' EMPTY
test_info 'foo.bar' 'log::info() foo.bar namespace' SAME
test_debug 'foo.bar' 'log::debug() foo.bar namespace' SAME
test_info 'foo.bar.la' 'log::info() foo.bar.la namespace' SAME
test_debug 'foo.bar.la' 'log::debug() foo.bar.la namespace foo.bar=DEBUG' SAME
test::newline

test::section 'level_specific_functions_enabled' 'Check all the level specific functions output when enabled'
log::set_level 'foo' ${TRACE}
test_error 'foo' 'log::error() for foo level=TRACE' SAME
test_warn 'foo' 'log::warm() for foo level=TRACE' SAME
test_info 'foo' 'log::info() for foo level=TRACE' SAME
test_debug 'foo' 'log::debug() for foo level=TRACE' SAME
test_trace 'foo' 'log::trace() for foo level=TRACE' SAME
test::section 'level_specific_functions_disabled' 'Check all the level specific functions output when disabled'
log::set_level 'foo' ${NONE}
test_error 'foo' 'log::error() for foo level=NONE' EMPTY
test_warn 'foo' 'log::warm() for foo level=NONE' EMPTY
test_info 'foo' 'log::info() for foo level=NONE' EMPTY
test_debug 'foo' 'log::debug() for foo level=NONE' EMPTY
test_trace 'foo' 'log::trace() for foo level=NONE' EMPTY

test::finish

#test::dump_sections

