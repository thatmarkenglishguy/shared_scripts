#!/usr/bin/env bash

#Deduce this script's directory
if [ -z ${BASH_SOURCE} ]; then
  test_logging_script_dir=$(readlink -f $(dirname "${0}"))
else
  test_logging_script_dir="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

# Log testing
source "${test_logging_script_dir}/../../bash_script_testing"
source "${test_logging_script_dir}/../../bash_script_logging"
# Importing twice shouldn't produce any error messages
# e.g. readonly variables being redeclared.
source "${test_logging_script_dir}/../../bash_script_logging"

# Log test results
function build_log_test_description() {
  # Test for log::log()
  # Paramters:
  #  1 level
  #  2 namespace
  #  3 message
  local level
  local namespace
  local message
  local description
  local description_namespace
  local description_level
  local description_level_number

  level=${1}
  namespace="${2}"
  message="${3}"

  description_level=${level}
  if [ -z "${description_level}" ]
  then
    description_level="DEFAULT_LEVEL(${_log_current_default_level}}"
    description_level_number=${_log_current_default_level}
  else
    description_level_number=${description_level}
  fi

  case "${description_level_number}" in
    ${ERROR})
      description_level="ERROR(${description_level})"
      ;;
    ${WARN})
      description_level="WARN(${description_level})"
      ;;
    ${INFO})
      description_level="INFO(${description_level})"
      ;;
    ${DEBUG})
      description_level="DEBUG(${description_level})"
      ;;
    ${TRACE})
      description_level="TRACE(${description_level})"
      ;;
  esac

  description_namespace="${namespace}"
  if [ -z "${description_namespace}" ]
  then
    description_namespace='DEFAULT_NAMESPACE'
  else
    description_namespace="'${description_namespace}'"
  fi

  description="log::log level=${description_level} namespace=${description_namespace} message='${message}'"
  echo "${description}"
}

function show_log_test_result() {
  local level
  local namespace
  local message
  local expected
  local output
  local description

  level=${1}
  namespace="${2}"
  message="${3}"
  expected="${4}"
  output="${5}"

  description="$(build_log_test_description "${level}" "${namespace}" "${message}")"

  test::assert_compare "${message}" "${expected}" "${output}" "${description}"
}

# Log functionality testing

function test_effective_level() {
  local namespace
  local expected_level
  local effective_level
  namespace="${1}"
  expected_level=${2}

  effective_level=$(log::_effective_log_level "${namespace}")

  test::assert_equal "${effective_level}" "${expected_level}" "Effective level"
}

function test_log() {
  # Test for log::log()
  # Paramters:
  #  1 level
  #  2 namespace
  #  3 message
  #  4 expected output. Note: EMPTY expects empty, SAME expects message,
  #                           anything else is used verbatim.
  local output

  output="$(log::log "${1}" "${2}" "${3}" 3>&2 2>&1 1>&3)"

  show_log_test_result "${1}" "${2}" "${3}" "${4}" "${output}"
}

# Testing specific level functions. All have the same parameters:
# Paramters:
#  1 namespace
#  2 message
#  3 expected output. Note: EMPTY expects empty, SAME expects message,
#                           anything else is used verbatim.
function test_error() {
  local output
  output="$(log::error "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${ERROR} "${1}" "${2}" "${3}" "${output}"
}

function test_warn() {
  local output
  output="$(log::warn "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${WARN} "${1}" "${2}" "${3}" "${output}"
}

function test_info() {
  local output
  output="$(log::info "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${INFO} "${1}" "${2}" "${3}" "${output}"
}

function test_debug() {
  local output
  output="$(log::debug "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${DEBUG} "${1}" "${2}" "${3}" "${output}"
}

function test_trace() {
  local output
  output="$(log::trace "${1}" "${2}" 3>&2 2>&1 1>&3)"

  show_log_test_result ${TRACE} "${1}" "${2}" "${3}" "${output}"
}

function test_build_message() {
  local format
  local level
  local namespace
  local raw_message
  local expected
  local output

  format="${1}"
  level="${2}"
  namespace="${3}"
  raw_message="${4}"
  expected="${5}"

  output="$(log::build_message "${format}" ${level} "${namespace}" "${raw_message}")"

  test::assert_match "${output}" "${expected}" "Format message format='${format}' level=${level} namespace='${namespace}' message='${raw_message}'"
}

## Command line
test::process_command_line_args "${0}" "${@}"

# The Tests
test::section 'effective_levels' 'Effective levels'
log::reset
#log::_dump_namespaces
test_effective_level 'foo' ${INFO}
test_effective_level 'foo.bar' ${INFO}
test_effective_level 'foo.bar.la' ${INFO}

test::announce 'set foo.bar to DEBUG'
log::set_level 'foo.bar' ${DEBUG}
#log::_dump_namespaces
test_effective_level 'foo' ${INFO}
test_effective_level 'foo.bar' ${DEBUG}
test_effective_level 'foo.bar.la' ${DEBUG}
test::newline

test::section 'changing_default_level' 'Logging and changing default level'
log::reset
# Default level is INFO
test_log '' '' 'log::log() default' SAME
test_log ${DEBUG} '' 'log::log() debug explicit' EMPTY
test_debug '' 'log::debug()' EMPTY
log::set_default_level ${DEBUG}
test_log ${DEBUG} '' 'log::log() debug with default level at DEBUG' SAME
test_log '' '' 'log::log() debug with default level at DEBUG' SAME
test_debug '' 'log::debug() with default level at DEBUG' SAME
test::newline

test::section 'namespace_levels' 'Namespace levels'
log::reset
test_info 'foo' 'log::info() foo namespace' SAME
test_debug 'foo' 'log::debug() foo namespace' EMPTY
test_info 'foo.bar' 'log::info() foo.bar namespace' SAME
test_debug 'foo.bar' 'log::debug() foo.bar namespace' EMPTY
test_info 'foo.bar.la' 'log::info() foo.bar.la namespace' SAME
test_debug 'foo.bar.la' 'log::debug() foo.bar.la namespace' EMPTY

test::announce 'set foo.bar to DEBUG'
log::set_level 'foo.bar' ${DEBUG}
test_info 'foo' 'log::info() foo namespace' SAME
test_debug 'foo' 'log::debug() foo namespace' EMPTY
test_info 'foo.bar' 'log::info() foo.bar namespace' SAME
test_debug 'foo.bar' 'log::debug() foo.bar namespace' SAME
test_info 'foo.bar.la' 'log::info() foo.bar.la namespace' SAME
test_debug 'foo.bar.la' 'log::debug() foo.bar.la namespace foo.bar=DEBUG' SAME
test::newline

test::section 'level_specific_functions_enabled' 'Check all the level specific functions output when enabled'
log::set_level 'foo' ${TRACE}
test_error 'foo' 'log::error() for foo level=TRACE' SAME
test_warn 'foo' 'log::warm() for foo level=TRACE' SAME
test_info 'foo' 'log::info() for foo level=TRACE' SAME
test_debug 'foo' 'log::debug() for foo level=TRACE' SAME
test_trace 'foo' 'log::trace() for foo level=TRACE' SAME
test::section 'level_specific_functions_disabled' 'Check all the level specific functions output when disabled'
log::set_level 'foo' ${NONE}
test_error 'foo' 'log::error() for foo level=NONE' EMPTY
test_warn 'foo' 'log::warm() for foo level=NONE' EMPTY
test_info 'foo' 'log::info() for foo level=NONE' EMPTY
test_debug 'foo' 'log::debug() for foo level=NONE' EMPTY
test_trace 'foo' 'log::trace() for foo level=NONE' EMPTY

test::section 'outputting_to_files' 'Outputting to files'
log::reset
test_output_file=$(mktemp)
log::set_stream_appender 'foo' "${test_output_file}"
log::trace 'foo.bar' 'TRACE Should not appear in file'
log::debug 'foo.bar' 'DEBUG Should not appear in file'
log::info 'foo.bar' 'INFO should appear in file'
log::warn 'foo.bar' 'WARN should appear in file'
log::error 'foo.bar' 'ERROR should appear in file'
test_info 'bar' 'Log to separate namespace should not go to file' SAME
test_expected_file=$(mktemp)
cat <<-EOF >"${test_expected_file}"
INFO should appear in file
WARN should appear in file
ERROR should appear in file
EOF
test::assert_file_content_same "${test_output_file}" "${test_expected_file}" 'Log output to file'

test::section 'building_message' 'Building formatted log messages'
## '%d/%b/%Y:%H:%M:%S %z'
## 00/Abc/1111:22:33:44 +5555
expr_date='[[:digit:]]{2}/[[:upper:]][[:lower:]]{2}/[[:digit:]]{4}:[[:digit:]]{2}:[[:digit:]]{2}:[[:digit:]]{2}[[:space:]]+\+[[:digit:]]{4}'
expr_ip_address='[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}'
log::reset
test_build_message 'test %<nope>' ${INFO} 'foo' 'test nope' '^test %<nope>$'
test_build_message 'test %<message>' ${INFO} 'foo' 'test message' '^test test message$'
test_build_message 'test %<level>' ${INFO} 'foo' 'test level' '^test INFO$'
test_build_message 'test %<lvl>' ${TRACE} 'foo' 'test level' '^test TRC$'
test_build_message 'test %<lvl>' ${DEBUG} 'foo' 'test level' '^test DBG$'
test_build_message 'test %<lvl>' ${INFO} 'foo' 'test level' '^test INF$'
test_build_message 'test %<lvl>' ${WARN} 'foo' 'test level' '^test WRN$'
test_build_message 'test %<lvl>' ${ERROR} 'foo' 'test level' '^test ERR$'
test_build_message 'test %<lvl>' $(( ERROR+1 )) 'foo' 'test level' "^test UNK\($((ERROR+1))\)$"
test_build_message 'test %<namespace>' ${INFO} 'foo' 'test namespace' '^test foo$'
test_build_message 'test %<timestamp>' ${INFO} 'foo' 'test timestamp' '^test [[:digit:]]+$'
test_build_message 'test %<date>' ${INFO} 'foo' 'test date without format' '^test '${expr_date}'$'
test_build_message 'test %<date %d/%m/%Y>' ${INFO} 'foo' 'test date with format' '^test [[:digit:]]{2}/[[:digit:]]{2}/[[:digit:]]{4}$'
test_build_message 'test %<ip>' ${INFO} 'foo' 'test ip address' '^test '${expr_ip_address}'$'
test_build_message 'test %<host>' ${INFO} 'foo' 'test hostname' '^test [[:alnum:]_]+$'
test_build_message 'test %<user>' ${INFO} 'foo' 'test user' '^test [[:alnum:]_]+$'
test_build_message 'test %<pid>' ${INFO} 'foo' 'test pid' '^test [[:digit:]]+$'
test_build_message 'test %<tid>' ${INFO} 'foo' 'test tid' '^test [[:digit:]]+$'
test_build_message 'test %<cmd>' ${INFO} 'foo' 'test cmd' '^test [[:alnum:]/[:space:]_\.]+$'
test_build_message 'test %<cmd_without_shell>' ${INFO} 'foo' 'test cmd_without_shell' '^test [[:alnum:]/[:space:]_\.]+$'

test::section 'format_by_namespace' 'Setting format at namespace level'
log::reset
log::set_format 'foo' 'start %<level>|%<namespace>: %<message> end'
test_info 'foo' 'message 1' 'start INFO|foo: message 1 end'
test_info 'bar' 'message 1' SAME
log::reset
test_info 'foo' 'reset clears the formatting' SAME
test::finish

#test::dump_sections

