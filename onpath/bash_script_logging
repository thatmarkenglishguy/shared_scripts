# :vim ft=bash

# Functions for logging.
# See log::usage for details.

if [ -z ${__script_logging_imported} ]
then
  readonly NONE=0
  readonly ERROR=10
  readonly WARN=20
  readonly INFO=30
  readonly DEBUG=40
  readonly TRACE=50
  readonly __LOG_ROOT_NAMESPACE='_'
  readonly __LOG_DEFAULT_FORMAT_DELIMITER=$'\u2588' # $'\u2588' is the Unicode block character.
  readonly __LOG_DEFAULT_LEVEL=${INFO}
  readonly __LOG_DEFAULT_FORMAT='%<message>\n'
  readonly __LOG_DEFAULT_STREAM_APPENDER=/dev/fd/2
  readonly __LOG_DEFAULT_DATE_FORMAT='%d/%b/%Y:%H:%M:%S %z'
  declare -A __log_levels
  declare -A __log_stream_appenders
  declare -A __log_formats
  __log_current_default_level=${__LOG_DEFAULT_LEVEL}
  __log_current_format_delimiter=${__LOG_DEFAULT_FORMAT_DELIMITER}
  __log_current_default_date_format="${__LOG_DEFAULT_DATE_FORMAT}"
  __log_current_default_format="${__LOG_DEFAULT_FORMAT}"
  __script_logging_imported=1
fi

# Usage
log::usage() {
  cat <<-EOF
Functions for logging.

Logs are namespaced using sensible module names delimited by '.'.
Log levels are: ERROR, WARN, INFO, DEBUG, TRACE.
Log levels are inherited from nearest parent.
Default log level is INFO.
Default log appender is STDERR.
Default log format is the message.

Available format specifiers:
Format syntax is %<FORMAT_SPECIFIER>.
 message       Log message
 level         Log level
 namespace     Log namespace
 timestamp     Timestamp now
 date[ FORMAT] Date now in optional format specified.
               Default format is: ${__LOG_DEFAULT_DATE_FORMAT}
 ip            IP address
 host          Hostname
 user          Username
 pid           Process ID
 tid           Thread ID
For example:
```
source script_logging
log::set_level 'some_module' \${INFO}
log::set_level 'some_module.sub.submodule2' \${WARN}
log::set_format 'some_module.format_example' 'start %<level>|%<namespace> %<message> end'
log::set_stream_sppender 'some_module.file_example' '~/my_log.log'
log::info 'some_module.sub.submodule1' 'a message for submodule 1' # Appears in log output
log::info 'some_module.sub.submodule2' 'a message for submodule 2' # Omitted from log output
log::info 'some_module.file_example' 'a message for a file' # Appears in file
Output for following line:
'start INFO|some_module.format_example a message for a file end'
log::info 'some_module.format_example' 'a message for a file'
```

EOF
}

# Logging internals
log::_dump_variables_by_prefix() {
  # Parameters:
  #  1 Prefix. Prefix of variables to dump out.
  echo "Variables prefixed with '${1}':" >&2
  compgen -v | grep "^${1}" >&2
}

log::_dump_namespaces() {
  local key
  local value
  echo 'Logging namespace start' >&2
  for key in "${!__log_levels[@]}"
  do
    value="${__log_levels[${key}]}"
    echo "${key}=${value}" >&2
  done 
  echo 'Logging namespace end' >&2
}

log::_build_namespace_key() {
  # Parameters:
  #  1 Namespace
  # Returns:
  #  Namespace key in the log internal associative arrays.
  local namespace_key
  namespace_key="${1}"

  echo "${namespace_key}"
}

log::_shorter_and_shorter_prefix() {
  # Parameters:
  #  1 A string of sub-strings with a delimiter.
  #  2. Namespace delimiter.
  # Outputs:
  #  Successive iterations of initial string with
  #  substring at end removed.
  # E.g.
  #  log::_shorter_and_shorter_prefix 'a.b.c.d' '.'
  # Produces:
  #  'a.b.c'
  #  'a.b'
  #  'a'
  local prefix
  local delim
  local prev

  prefix="${1}"
  delim="${2-.}"
  prev=''

  while [ "${prev}" != "${prefix}" ]
  do
    echo "${prefix}"
    prev="${prefix}"
    prefix="${prefix%${delim}*}"
  done
}

log::_loop_effective_log_level() {
  # Globals:
  #  __log_levels
  # Parameters:
  #  1 Namespace. e.g. 'outer.inner.sub'
  # Outputs:
  #  Effective log level for specified namespace string, if found,
  #  otherwise default log level.
  # Returns:
  #  0 if effective log level found.
  #  1 if effective log level not found.
  local name

  while read name
  do
    if [[ -v "__log_levels[${name}]" ]]
    then
      echo ${__log_levels[${name}]}
      return 0
    fi
  done < <(log::_shorter_and_shorter_prefix "${1}" '.' )

  return 1
}

log::_effective_log_level() {
  # Globals:
  #  __log_current_default_level
  # Parameters:
  #  1 Namespace. e.g. 'outer.inner.sub'
  # Returns:
  #  Effective log level for specified namespace string,
  #  or default level if not found.
  if ! log::_loop_effective_log_level "${1}"
  then
    echo ${__log_current_default_level}
    return 1
  else
    return 0
  fi
}

log::_loop_effective_log_stream_appender() {
  # Globals:
  #  __log_stream_appenders
  # Parameters:
  #  1 Namespace. e.g. 'outer.inner.sub'
  # Outputs:
  #  Effective log stream appender for specified namespace string, if found,
  #  otherwise default log stream appender.
  # Returns:
  #  0 if effective log stream appender found.
  #  1 if effective log stream appender not found.
  local name

  while read name
  do
    if [[ -v "__log_stream_appenders[${name}]" ]]
    then
      echo ${__log_stream_appenders[${name}]}
      return 0
    fi
  done < <(log::_shorter_and_shorter_prefix "${1}" '.' )

  return 1
}

log::_effective_log_stream_appender() {
  # Globals:
  #   __LOG_DEFAULT_STREAM_APPENDER
  # Parameters:
  #  1 Namespace. e.g. 'outer.inner.sub'
  # Returns:
  #  Effective log stream appender for specified namespace string,
  #  or default log stream appender if not found.
  if ! log::_loop_effective_log_stream_appender "${1}"
  then
    echo ${__LOG_DEFAULT_STREAM_APPENDER}
    return 1
  else
    return 0
  fi
}

log::_loop_effective_log_format() {
  # Globals:
  #  __log_formats
  # Parameters:
  #  1 Namespace. e.g. 'outer.inner.sub'
  # Outputs:
  #  Effective log format for specified namespace string, if found,
  #  otherwise default log format .
  # Returns:
  #  0 if effective log format found.
  #  1 if effective log format not found.
  local name

  while read name
  do
    if [[ -v "__log_formats[${name}]" ]]
    then
      echo ${__log_formats[${name}]}
      return 0
    fi
  done < <(log::_shorter_and_shorter_prefix "${1}" '.' )

  return 1
}

log::_effective_log_format() {
  # Globals:
  #  __log_current_default_format
  # Parameters:
  #  1 Namespace. e.g. 'outer.inner.sub'
  # Returns:
  #  Effective log format for specified namespace string,
  #  or default log format if not found.
  if ! log::_loop_effective_log_format "${1}"
  then
    echo ${__log_current_default_format}
    return 1
  else
    return 0
  fi
}


log::_loop_format_tokens() {
  # Loops through a format string breaking into tokens.
  # Parameters:
  #  1 Format string to parse.
  #  2 Delimiter to separate tokens. Defaults to $'\u2588' (Unicode block character).
  #
  # Outputs:
  #  Pair of tokens: prefix format_field. These are delimited by the delimiter.
  local original_format_string
  local delim
  local next_string
  local regex
  local matched_token
  local extracted_group
  local prefix
  local start_position

  original_format_string="${1}"
  delim=${2:-${__log_current_format_delimiter}}

  next_string="${original_format_string}"
  regex='%<([a-z]+)>'
  regex='%<([[:alnum:]]+[[:space:]]*[[:alpha:]%+-/]+)>'

  while [[ "$next_string" =~ $regex ]]; do
    matched_token="${BASH_REMATCH[0]}"
    extracted_group="${BASH_REMATCH[1]}"

    # Calculate the start position by getting the length of the string before the match
    prefix="${next_string%%"${matched_token}"*}"
    start_position="${#prefix}"

    echo -e "${prefix}"${delim}"${extracted_group}"

    # Remove the matched part from the string
    next_string="${next_string:$start_position + ${#matched_token}}"
  done

  echo "${next_string}"
}

# Log formatting

log::_level_string() {
  # Parameters:
  #  1 Log level
  # Outputs:
  #  String equivalent of log level.
  local level
  local level_string
  level="${1}"

  case "${level}" in
    ${ERROR})
      level_string="ERROR"
      ;;
    ${WARN})
      level_string="WARN"
      ;;
    ${INFO})
      level_string="INFO"
      ;;
    ${DEBUG})
      level_string="DEBUG"
      ;;
    ${TRACE})
      level_string="TRACE"
      ;;
    *)
      level_string="UNKNOWN_LEVEL(${level})"
      ;;
  esac

  echo "${level_string}"
}

# Log functions for external scripts to call.

log::build_message() {
  # Globals:
  #   __log_current_format_delimiter
  #   __log_current_default_date_format
  # Parameters:
  #  1 Format string
  #  2 Log level
  #  3 Log namespace
  #  4 Message
  # Outputs:
  #  Formatted message
  local format
  local level
  local namespace
  local raw_message
  local message
  local prefix
  local token
  local level_string
  local timestamp
  local date_format
  local date

  format="${1}"
  level="${2}"
  namespace="${3}"
  raw_message="${4}"

  message=''

  while IFS=${__log_current_format_delimiter} read -r prefix token
  do
    message="${message}${prefix}"

    if [ -n "${token}" ]
    then
      case "${token}" in
        message)
          message="${message}${raw_message}"
          ;;
        level)
          level_string="$(log::_level_string ${level})"
          message="${message}${level_string}"
          ;;
        namespace)
          message="${message}${namespace}"
          ;;
        timestamp)
          timestamp=$(date "+%s%N")
          message="${message}${timestamp}"
          ;;
        date*)
          if [ "${token}" != 'date' ]
          then
            # Presumably there's a format string in there
            if [[ "${token}" =~ date[[:space:]]*([^>]*) ]]
            then
              date_format="${BASH_REMATCH[1]}"
            else
              date_format="${__log_current_default_date_format}"
            fi
          else
            date_format="${__log_current_default_date_format}"
          fi

          date="$(date "+${date_format}")"
          message="${message}${date}"
          ;;
        ip)
          message="${message}$(hostname -i)"
          ;;
        host)
          message="${message}$(hostname)"
          ;;
        user)
          message="${message}${USER}"
          ;;
        pid)
          message="${message}$$"
          ;;
        tid)
          message="${message}$(ps --no-headers --format tid $$)"
          ;;
        *)
          message="${message}%<${token}>"
          ;;
      esac
    fi
  done < <(log::_loop_format_tokens "${format}" ${__log_current_format_delimiter})

  message="$(echo -e "${message}")"
  printf "%s" "${message}"
}

log::set_default_level() {
  __log_current_default_level=${1}
}

log::log() {
  # Top level logging function.
  # Typically not called directly.
  # Instead log::error, log::warn, log::info, log::debug, log::trace
  # are used.
  #
  # Globals:
  #  __LOG_DEFAULT_FORMAT
  #  __log_current_default_level
  # Parameters:
  #  1 Level to log at. e.g. '${INFO}'
  #  2 Namespace. e.g. 'outer.inner.sub'
  #  3 Message to log
  # Outputs:
  #  Log message
  local level
  local namespace
  local raw_message
  local effective_level
  local effective_format
  local effective_stream_appender
  local message

  level=${1}

  if [ -z "${level}" ]
  then
    level=${__log_current_default_level}
  fi

  namespace="${2}"
  if [ -z "${namespace}" ]
  then
    namespace="${__LOG_ROOT_NAMESPACE}"
  else
    namespace=$(log::_build_namespace_key "${namespace}")
  fi

  raw_message="${3}"

  effective_level=$(log::_effective_log_level "${namespace}")
  effective_format="$(log::_effective_log_format "${namespace}")"
  effective_stream_appender="$(log::_effective_log_stream_appender "${namespace}")"

  if [ ${level} -le ${effective_level} ]
  then
    message="$(log::build_message "${effective_format}" "${effective_level}" "${namespace}" "${raw_message}")"
    echo "${message}" >>"${effective_stream_appender}"
  fi
}

log::error() {
  log::log ${ERROR} "${@}"
}

log::warn() {
  log::log ${WARN} "${@}"
}

log::info() {
  log::log ${INFO} "${@}"
}

log::debug() {
  log::log ${DEBUG} "${@}"
}

log::trace() {
  log::log ${TRACE} "${@}"
}

log::set_level() {
  # Set the log level for the specified namespace.
  # Affects all sub-namespaces unless they have an explicit setting registered.
  #
  # Globals:
  #  __log_levels
  # Parameters:
  #  1 Namespace
  #  2 Log level
  local namespace
  local level

  namespace="$(log::_build_namespace_key "${1}")"
  level=${2}

  __log_levels["${namespace}"]=${level}
}

log::set_stream_appender() {
  # Set a stream appender for the specified namespace.
  # Affects all sub-namespaces unless they have an explicit setting registered.
  #
  # Globals:
  #  __log_stream_appenders
  # Parameters:
  #  1 Namespace
  #  2 Stream identifier
  local namespace
  local stream
  local dir

  namespace="$(log::_build_namespace_key "${1}")"
  stream="${2}"

  dir="$(dirname "${stream}")"
  if [ -n "${dir}" ] && [ ! -d "${dir}" ] && [ "${dir}" != '.' ]
  then
    mkdir -p "${dir}"
    touch "${stream}"
  fi

  __log_stream_appenders["${namespace}"]="${stream}"
}

log::set_format() {
  # Set a format for the specified namespace.
  # Affects all sub-namespaces unless they have an explicit setting registered.
  #
  # Globals:
  #  __log_formats
  # Parameters:
  #  1 Namespace
  #  2 Format
  local namespace
  local format

  namespace="$(log::_build_namespace_key "${1}")"
  format="${2}"

  __log_formats["${namespace}"]="${format}"
}

log::reset() {
  # Globals:
  #  __log_levels
  #  __log_stream_appenders
  #  __log_formats
  #  __log_current_default_level
  #  __log_current_format_delimiter
  #  __log_current_default_date_format
  #  __log_current_default_format

  __log_levels=()
  __log_stream_appenders=()
  __log_formats=()

  __log_current_format_delimiter=${__LOG_DEFAULT_FORMAT_DELIMITER}
  __log_current_default_date_format="${__LOG_DEFAULT_DATE_FORMAT}"
  __log_current_default_format="${__LOG_DEFAULT_FORMAT}"

  __script_logging_imported=1
  log::set_default_level ${__LOG_DEFAULT_LEVEL}
}

log::reset

